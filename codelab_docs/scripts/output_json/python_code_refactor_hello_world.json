{
  "visualizerType": "CodeRefactorChallenge",
  "visualizerParams": {
    "title": "Optimizing Even Number Extraction",
    "problemDescription": "Refactor the provided Python code to efficiently extract even numbers from a list. The current implementation is inefficient due to repeated list reconstruction, leading to quadratic time complexity (O(N^2)) in the worst case. Your goal is to simplify and optimize the code to achieve linear time complexity (O(N)).",
    "language": "python",
    "initialCode": "def get_even_numbers(numbers_list):\n    # Initialize an empty list that will eventually hold our even numbers.\n    # This list will be inefficiently built up.\n    all_current_even_values = [] \n\n    # We iterate through each number in the input list.\n    for current_number_to_check in numbers_list:\n        # Check if the current number is even.\n        if current_number_to_check % 2 == 0:\n            # If it's even, instead of a simple append, we perform an O(N) operation.\n            # We create a brand new list that contains all previously found even numbers\n            # plus the current even number. This means copying all elements repeatedly.\n            \n            temporary_list_for_rebuilding = []\n            \n            # Copy all elements from the old list of evens\n            for existing_even_value in all_current_even_values:\n                temporary_list_for_rebuilding.append(existing_even_value)\n            \n            # Add the new even number\n            temporary_list_for_rebuilding.append(current_number_to_check);\n            \n            # Replace the old list with the newly built one.\n            # This repeated allocation and copying is O(k) for each even number 'k' found so far.\n            # If there are 'E' even numbers, the total complexity becomes O(E^2),\n            # which is O(N^2) in the worst case (all numbers are even).\n            all_current_even_values = temporary_list_for_rebuilding\n        else:\n            # For odd numbers, we just do nothing, but this branch is an unnecessary aesthetic element.\n            pass\n            \n    # Finally, return the list of even numbers.\n    return all_current_even_values\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(get_even_numbers(nums))",
    "solution": {
      "code": "def get_even_numbers(numbers):\n    evens = []\n    for num in numbers:\n        if num % 2 == 0:\n            evens.append(num)\n    return evens\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(get_even_numbers(nums))",
      "explanation": "The initial code repeatedly creates new lists (`temporary_list_for_rebuilding`) and copies all previously found even numbers into them, plus the current even number. This process involves re-allocating memory and copying elements every time an even number is found. If 'k' even numbers have been found so far, copying them takes O(k) time. Summing this up over all 'E' even numbers found, the total time complexity becomes O(E^2), which is O(N^2) in the worst case (when all numbers in the input list are even).\n\nThe optimized solution, in contrast, initializes a single empty list (`evens`) and uses the `append()` method to add even numbers. Python's `list.append()` operation is amortized O(1) (constant time). This is because lists are dynamically sized arrays that are typically over-allocated, meaning they don't need to reallocate and copy elements for every single append. When a reallocation is necessary, it happens infrequently and involves allocating a larger block of memory. Therefore, iterating through the list once and appending to a single list results in a linear time complexity of O(N), which is significantly more efficient for large input lists than the quadratic approach."
    }
  }
}